import pytest
import pandas as pd
import numpy as np
from unittest.mock import MagicMock

# Block for module import - DO NOT REMOVE OR MODIFY
from definition_b5ea310f3a4740f7ab7128e455e5bb98 import run_alpha_path_analysis
# End of block


# --- Mocks for dependencies ---
class MockMLModel:
    """Mock for the ML model with a predictable predict method."""
    def predict(self, X: pd.DataFrame) -> np.ndarray:
        # Simulate predictions based on 'feature_to_shock' if present, otherwise a baseline.
        if 'feature_to_shock' in X.columns:
            # Simple linear response for testing: base_PD + (feature_value * impact_factor)
            # Clip to [0, 1] for probability realism.
            # Example: initial feature value 10 -> PD=0.1 + 10*0.01 = 0.2
            return np.clip(0.1 + X['feature_to_shock'] * 0.01, 0.0, 1.0).to_numpy()
        return np.full(len(X), 0.1) # Baseline PD if no specific feature to shock

def mock_apply_feature_shock(df: pd.DataFrame, shocks_dict: dict, shock_type: str) -> pd.DataFrame:
    """
    Mock for apply_feature_shock that applies shocks as per run_alpha_path_analysis's interpretation.
    It directly applies the `current_shock_value` (which is `base_shock_value * alpha`) to the feature.
    """
    df_stressed = df.copy()
    if shock_type not in ['multiplicative', 'additive']:
        raise ValueError("mock_apply_feature_shock: shock_type must be 'multiplicative' or 'additive'")

    for feature, current_shock_value in shocks_dict.items():
        if feature in df_stressed.columns:
            if shock_type == 'multiplicative':
                # As per run_alpha_path_analysis's specific instruction:
                # `current_shocks_dict` is generated by `v * alpha`.
                # `apply_feature_shock` then applies this `current_shock_value` directly.
                df_stressed[feature] *= current_shock_value
            elif shock_type == 'additive':
                df_stressed[feature] += current_shock_value
        # If feature not in df_stressed.columns, we ignore for mock simplicity
    return df_stressed

# --- Fixtures for common setup ---
@pytest.fixture
def sample_model():
    """Returns an instance of the MockMLModel."""
    return MockMLModel()

@pytest.fixture
def sample_X_baseline():
    """Returns a sample DataFrame for X_baseline."""
    return pd.DataFrame({'feature_to_shock': [10.0, 20.0, 30.0], 'other_feature': [1, 2, 3]})

@pytest.fixture
def sample_base_shocks():
    """
    Returns a sample base_shocks dictionary.
    The value `0.5` is interpreted as the direct multiplicative factor at alpha=1.
    """
    return {'feature_to_shock': 0.5}

@pytest.fixture
def sample_alpha_steps():
    """Returns a list of alpha steps for testing."""
    return np.linspace(0, 1, 3).tolist() # [0.0, 0.5, 1.0]

# --- Test cases ---
def test_run_alpha_path_analysis_standard_multiplicative(mocker, sample_model, sample_X_baseline, sample_base_shocks, sample_alpha_steps):
    """
    Test a standard scenario with multiplicative shocks and varying alpha steps.
    Verifies DataFrame structure and expected Mean PD trajectory based on mock logic.
    """
    mocker.patch('definition_b5ea310f3a4740f7ab7128e455e5bb98.apply_feature_shock', side_effect=mock_apply_feature_shock)

    # Expected trajectory based on the mock logic:
    # X_baseline['feature_to_shock'] = [10.0, 20.0, 30.0]
    # sample_base_shocks = {'feature_to_shock': 0.5}
    # sample_model.predict: np.clip(0.1 + X['feature_to_shock'] * 0.01, 0.0, 1.0)

    # Alpha = 0.0: current_shock = 0.0. X_stressed = [0,0,0]. y_hat = [0.1,0.1,0.1]. Mean PD = 0.1
    # Alpha = 0.5: current_shock = 0.25. X_stressed = [2.5,5.0,7.5]. y_hat = [0.125,0.15,0.175]. Mean PD = 0.15
    # Alpha = 1.0: current_shock = 0.5. X_stressed = [5.0,10.0,15.0]. y_hat = [0.15,0.2,0.25]. Mean PD = 0.2
    expected_mean_pds = [0.1, 0.15, 0.2]

    result_df = run_alpha_path_analysis(sample_model, sample_X_baseline, sample_base_shocks, sample_alpha_steps, 'multiplicative')

    assert isinstance(result_df, pd.DataFrame)
    assert list(result_df.columns) == ['Alpha', 'Mean PD']
    assert result_df['Alpha'].tolist() == sample_alpha_steps
    np.testing.assert_allclose(result_df['Mean PD'].to_numpy(), expected_mean_pds, rtol=1e-5)

def test_run_alpha_path_analysis_empty_alpha_steps(mocker, sample_model, sample_X_baseline, sample_base_shocks):
    """
    Test with an empty list of alpha steps.
    Should return an empty DataFrame with the correct column names.
    """
    mocker.patch('definition_b5ea310f3a4740f7ab7128e455e5bb98.apply_feature_shock', side_effect=mock_apply_feature_shock)
    
    alpha_steps = []
    result_df = run_alpha_path_analysis(sample_model, sample_X_baseline, sample_base_shocks, alpha_steps, 'multiplicative')

    assert isinstance(result_df, pd.DataFrame)
    assert result_df.empty
    assert list(result_df.columns) == ['Alpha', 'Mean PD']

def test_run_alpha_path_analysis_empty_base_shocks(mocker, sample_model, sample_X_baseline, sample_alpha_steps):
    """
    Test with an empty base_shocks dictionary.
    Mean PD should remain constant (baseline) across all alpha steps.
    """
    mocker.patch('definition_b5ea310f3a4740f7ab7128e455e5bb98.apply_feature_shock', side_effect=mock_apply_feature_shock)

    base_shocks = {} # No shocks defined
    result_df = run_alpha_path_analysis(sample_model, sample_X_baseline, base_shocks, sample_alpha_steps, 'multiplicative')

    assert isinstance(result_df, pd.DataFrame)
    assert list(result_df.columns) == ['Alpha', 'Mean PD']
    assert result_df['Alpha'].tolist() == sample_alpha_steps
    
    # Calculate baseline mean PD for sample_X_baseline:
    # X_baseline['feature_to_shock'] = [10.0, 20.0, 30.0]
    # y_hat_baseline = [0.1+10*0.01, 0.1+20*0.01, 0.1+30*0.01] = [0.2, 0.3, 0.4]
    # Mean PD = (0.2 + 0.3 + 0.4) / 3 = 0.3
    expected_constant_mean_pd = 0.3
    np.testing.assert_allclose(result_df['Mean PD'].to_numpy(), np.full(len(sample_alpha_steps), expected_constant_mean_pd), rtol=1e-5)

def test_run_alpha_path_analysis_invalid_shock_type(mocker, sample_model, sample_X_baseline, sample_base_shocks, sample_alpha_steps):
    """
    Test with an invalid shock_type.
    Should raise a ValueError, as handled by the mock_apply_feature_shock.
    """
    mocker.patch('definition_b5ea310f3a4740f7ab7128e455e5bb98.apply_feature_shock', side_effect=mock_apply_feature_shock)
    
    invalid_shock_type = 'invalid_type'
    with pytest.raises(ValueError, match="shock_type must be 'multiplicative' or 'additive'"):
        run_alpha_path_analysis(sample_model, sample_X_baseline, sample_base_shocks, sample_alpha_steps, invalid_shock_type)

def test_run_alpha_path_analysis_non_dataframe_X_baseline(mocker, sample_model, sample_base_shocks, sample_alpha_steps):
    """
    Test with X_baseline being a non-DataFrame object.
    Should raise an AttributeError or TypeError when pandas methods like .copy() are called.
    """
    mocker.patch('definition_b5ea310f3a4740f7ab7128e455e5bb98.apply_feature_shock', side_effect=mock_apply_feature_shock)
    
    non_df_X_baseline = [1, 2, 3] # A list instead of a DataFrame
    # The function will try to call .copy() on X_baseline, which will fail for a list.
    with pytest.raises(AttributeError, match="list object has no attribute 'copy'"):
        run_alpha_path_analysis(sample_model, non_df_X_baseline, sample_base_shocks, sample_alpha_steps, 'multiplicative')